name: Golden Keyword Miner Cron

on:
  schedule:
    - cron: '*/5 * * * *' # Run every 5 minutes (UTC) - Í≥µÍ≤©Ï†Å Î™®Îìú
  workflow_dispatch: # Allow manual trigger

jobs:
  mine:
    runs-on: ubuntu-latest
    timeout-minutes: 8 # 5Î∂Ñ ÌÅ¨Î°† ÎÇ¥ÏóêÏÑú Î£®ÌîÑ Ìò∏Ï∂úÎ°ú Ï≤òÎ¶¨Îüâ Í∑πÎåÄÌôî
    concurrency:
      group: miner-cron
      cancel-in-progress: true
    
    steps:
      - name: Trigger Miner API
        id: mining
        run: |
          set -e  # ÏóêÎü¨ Ïãú Ï¶âÏãú Ï§ëÎã®
          
          # ÌôòÍ≤Ω Î≥ÄÏàò Í≤ÄÏ¶ù
          if [ -z "${{ secrets.PROD_URL }}" ] || [ -z "${{ secrets.CRON_SECRET }}" ]; then
            echo "‚ùå ERROR: PROD_URL or CRON_SECRET is not set in GitHub Secrets."
            exit 1
          fi
          
          START_TIME=$(date +%s)
          echo "üöÄ Starting mining batch at $(date -u +"%Y-%m-%d %H:%M:%S UTC")"

          # Aggressive loop:
          # - GitHub schedule minimum is 5 minutes.
          # - Inside each run, repeatedly call the miner API for ~3 minutes to maximize daily throughput.
          # - Keep each API call within Vercel 60s by using smaller batches + controlled concurrency.
          RUN_FOR_SECONDS=180
          INTERVAL_SECONDS=20
          END_TIME=$((START_TIME + RUN_FOR_SECONDS))

          # Tuning knobs (safe defaults) for MAX Related Keywords (Ad API):
          # - expandBatch=32 => ~32 Ad API calls per miner execution (1 call per seed)
          # - expandConcurrency=4 => match 4 Ad keys
          # - minSearchVolume=0 => don't block by volume; maximize throughput
          # Target Ad calls/day (upper bound): (180/20=9 calls/run) * 32 * 288 ~= 82,944
          # If you want to push closer to 100k/day, try expandBatch=38~40 (watch 60s timeout/429).
          QUERY="task=expand&expandBatch=32&expandConcurrency=4&minSearchVolume=0&maxRunMs=55000"

          TOTAL_OK=0
          TOTAL_FAIL=0

          while [ $(date +%s) -lt $END_TIME ]; do
            echo "üì° Calling miner: ${{ secrets.PROD_URL }}/api/miner/execute?$QUERY"

            # Per-call retry (keep short)
            MAX_RETRIES=2
            RETRY_COUNT=0
            SUCCESS=false

            while [ $RETRY_COUNT -lt $MAX_RETRIES ] && [ "$SUCCESS" = "false" ]; do
              RESPONSE=$(curl -X GET "${{ secrets.PROD_URL }}/api/miner/execute?$QUERY" \
                -H "CRON_SECRET: ${{ secrets.CRON_SECRET }}" \
                -w "\n%{http_code}" \
                --max-time 75 \
                --silent \
                --show-error) || true

              HTTP_CODE=$(echo "$RESPONSE" | tail -n1)
              BODY=$(echo "$RESPONSE" | sed '$d')

              if [ "$HTTP_CODE" = "200" ]; then
                SUCCESS=true
                TOTAL_OK=$((TOTAL_OK + 1))
                echo "‚úÖ HTTP $HTTP_CODE"
                echo "$BODY" | jq '.' || echo "$BODY"
              else
                RETRY_COUNT=$((RETRY_COUNT + 1))
                echo "‚ö†Ô∏è  HTTP $HTTP_CODE (retry $RETRY_COUNT/$MAX_RETRIES)"
                echo "Response: $BODY"
                sleep $((RETRY_COUNT * 3))
              fi
            done

            if [ "$SUCCESS" = "false" ]; then
              TOTAL_FAIL=$((TOTAL_FAIL + 1))
              echo "‚ùå Call failed after retries"
            fi

            sleep $INTERVAL_SECONDS
          done

          END_TIME=$(date +%s)
          DURATION=$((END_TIME - START_TIME))
          
          echo "üìà Loop summary: OK=$TOTAL_OK FAIL=$TOTAL_FAIL"
          echo "‚è±Ô∏è  Total execution time: ${DURATION} seconds"
          echo "üéâ Mining batch completed successfully!"

